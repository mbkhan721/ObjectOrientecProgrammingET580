/*
#include <iostream>
using namespace std;
// THE BIG THREE OR THE RULE OF THREE

// Member functions required for classes that use dynamic memory.
// Shallow copy versions are automatically generated by the compiler.
// Deep copy versions must be coded by the programmer.

// FUNCTIONS THAT ARE AUTOMATICALLY CREATED BY THE PROGRAM WHEN YOU DON'T WRITE THEM:

// 1) COPY CONSTRUCTOR: A function that initializes a new object from an existing object.
// It constructs one object from another object. If you have object a and want to construct object b,
// you send a to the copy constructor and it constructs b so that's identical to a.

// 2) ASSIGNMENT OVERLOAD: A function that copies all data from one object to another object.
// c1 = c2 and that copies data from c2 and stores it into c1. They're not the same objects, but they
// are equivalent.

// 3) DESTRUCTOR: A function that manages memory when an object is destroyed.
// When an object goes out of scope and determines what happens in terms of managing the memory of
// the object. Destructor is used for the deletion of dynamic memory that's created when an object is
// constructed to avoid memory leaks.

// These are automatically created by the compiler but they only deal with shallow copy. If I try to
// use the copy constructor in a class that has automatic memory, it'll construct object from another.
// But if I have class that uses dynamic memory and i try to use the copy constructor, we are gonna have
// two objects with different names but they're gonna share the same memory.
// And the same thing is true for assignment overload, if i try to copy one object to another, we'll
// have two objects that share the memory.
// That's because the compiler versions of these functions all do shallow copy.

// When programming classes that use pointers that point to dynamic memory, you must code as the big
// three because if we don't, we'll have problems with objects sharing and memory leaks.

// 1.
// -------------------------------------------------------- Copy Constructor:
class Course {
public:
    int *number;                                                // Dynamic data member
    Course(int n): number(new int(n)) {}                        // Constructor which constructs a course object
                                                                // using n variable to allocate dynamic memory
                                                                // which is pointed to *number data member.

    Course(const Course &c): number(new int(*(c.number))) {}    // copy constructor
                                                                // It has a single parameter which is an object
                                                                // of type Course. It's a const object and it's
                                                                // passed by reference.
    // In Copy constructor, we create a new object which has all of the values of the object c. So we'll have two
    // objects that are equivalent when we're done with this. When we populate the number field of the object
    // that we're creating, we utilize the memory from c or the value that's in c to do so, because c is
    // passed by reference. Instead of saying (new int(n)), we say new int then we go to c.number, we
    // de-reference that and that's the value that's used to create our new dynamic memory which is pointed
    // to number. (new int(*(c.number)))
};

// 2.
// -------------------------------------------------------- Assignment Operator Overload:
class AssignmentOperator {
public:
    int *number;                                                    // Dynamic data member
    AssignmentOperator(int n): number(new int(n)) {}                // Constructor which allocates new memory
                                                                    // and stores the value n in it.

    // This is the object what we are copying from _|________
    AssignmentOperator& operator=(const AssignmentOperator &c) {    // assignment (=) operator overload
        if (this != &c) {                                           // Are the objects different or the same
            *number = *(c.number);                                  // deep copy
        }
    return *this;                                                   // return the modified calling object
    }
};
// This is the memory address of the calling object which is c1. The function above says is the memory
// address of the calling object equivalent to the memory address of the parameter object? The
// parameter object is in parenthesis (const AssignmentOperator &c).
// If they're equivalent, there's nothing to copy and we jump to the line that says return this;
// return this; is a reference to c1. return *this is the calling object so we're returning c1 but we're
// returning it bu reference which means that we're returning the same object that was originally called
// the function. If both objects are different, like c2 and c1 which is 575 and 580, then we are going to do
// the copy.


// 3.
// -------------------------------------------------------- Destructor:
class Destructor {
public:
    int *number;                                        // Pointer to dynamic memory.
    Destructor(int n): number(new int(n)) {}            // Constructor which allocated dynamic memory.
    ~Destructor() {delete number;}                      // Destructor - Tilde character before it to say
                                                        // that this is a destructor.
                                                        // It deleted the dynamic memory pointed to by
                                                        // number.

    void f() {
        Destructor c{575};
    }                                                   // c goes out of scope so the destructor is
                                                        // automatically called to clean up the memory of
                                                        // the course object. If there's no destructor, when
                                                        // void() goes out of scope, we'll have a memory leak.
};



// *********************************************************************************
// **************************      MAIN FUNCTION     *******************************
// *********************************************************************************

int main() {

    // 1.
    // -------------------------------------------------------- Copy Constructor:
    cout << "\n1. --------------------- Copy Constructor: \n";

    Course c1{575};          // Call the one-parameter constructor
    Course c2{c1};              // call the copy constructor
                                // I'm send an object to c2 as it's being created. This calls the copy
                                // constructor.
                                // c.number is deep copied to number because we use the pointer dereference
                                // mechanism.
                                // Number is initialized using dynamic memory.


    // 2.
    // -------------------------------------------------------- Assignment Operator Overload:
    cout << "\n2. --------------------- Assignment Operator Overload: \n";

    AssignmentOperator c3{575};             // Call the one-parameter constructor
    AssignmentOperator c4{580};             // Call the one-parameter constructor
    c3 = c4;                                   // Call the assignment operator overload

    // c.number must be de-referenced to access number data.


    // 3.
    // -------------------------------------------------------- Destructor:
    cout << "\n3. --------------------- Destructor: \n";


    cout << "\n";
    return 0;
}
*/